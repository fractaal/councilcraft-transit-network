-- CouncilCraft Composer
-- Lightweight package manager for distributing ComputerCraft software from GitHub

local composer = {}

local STATE_PATH = "/.composer/state.json"
local INDEX_URL = "https://raw.githubusercontent.com/fractaal/councilcraft-transit-network/main/packages/index.json"
local json = {}
json.encode = textutils.serializeJSON
json.decode = textutils.unserializeJSON

local function http_get(url, binary)
  local headers = {}  -- Empty table instead of nil
  local resp
  if binary then
    resp = http.get(url, headers, true)
  else
    resp = http.get(url, headers)
  end
  if not resp then
    return nil, "HTTP request failed for " .. url
  end
  return resp
end

local function ensure_dir(path)
  local dir = fs.getDir(path)
  if dir ~= "" and not fs.exists(dir) then
    fs.makeDir(dir)
  end
end

local state = { packages = {} }

local function load_state()
  if fs.exists(STATE_PATH) then
    local handle = fs.open(STATE_PATH, "r")
    if handle then
      local content = handle.readAll()
      handle.close()
      if content and content ~= "" then
        local parsed = json.decode(content)
        if parsed and type(parsed) == "table" and parsed.packages then
          state = parsed
          return
        end
      end
    end
  end
  state = { packages = {} }
end

local function save_state()
  ensure_dir(STATE_PATH)
  local handle = fs.open(STATE_PATH, "w")
  if handle then
    handle.write(json.encode(state))
    handle.close()
  end
end

load_state()

local function load_index()
  local resp, err = http_get(INDEX_URL)
  if not resp then
    return nil, err
  end

  -- Verify response handle is valid before reading
  if type(resp) ~= "table" or type(resp.readAll) ~= "function" then
    return nil, "Invalid HTTP response handle"
  end

  local body = resp.readAll()
  resp.close()

  if not body or body == "" then
    return nil, "Empty response from index"
  end

  local parsed = json.decode(body)
  if not parsed or type(parsed.packages) ~= "table" then
    return nil, "Invalid composer index"
  end
  return parsed.packages
end

local function load_manifest(package_entry)
  local url = package_entry.manifest
  if not url then
    return nil, "Manifest URL missing"
  end
  local resp, err = http_get(url)
  if not resp then
    return nil, err
  end

  -- Verify response handle is valid before reading
  if type(resp) ~= "table" or type(resp.readAll) ~= "function" then
    return nil, "Invalid HTTP response handle"
  end

  local body = resp.readAll()
  resp.close()

  if not body or body == "" then
    return nil, "Empty response from manifest"
  end

  local manifest = json.decode(body)
  if not manifest or type(manifest) ~= "table" then
    return nil, "Invalid manifest for package"
  end
  return manifest
end

local function download_file(url, destination)
  local resp, err = http_get(url, true)
  if not resp then
    return false, err
  end

  -- Verify response handle is valid before reading
  if type(resp) ~= "table" or type(resp.readAll) ~= "function" then
    return false, "Invalid HTTP response handle"
  end

  local data = resp.readAll()
  resp.close()

  if not data or data == "" then
    return false, "Empty response"
  end

  ensure_dir(destination)
  local temp_path = destination .. ".tmp"
  if fs.exists(temp_path) then fs.delete(temp_path) end
  local handle = fs.open(temp_path, "wb")
  if not handle then
    return false, "Unable to open temp file " .. temp_path
  end
  handle.write(data)
  handle.close()
  if fs.exists(destination) then fs.delete(destination) end
  fs.move(temp_path, destination)
  return true
end

local function write_startup_stub(package_name, startup)
  if not startup or not startup.path or not startup.command then
    return
  end
  local path = startup.path
  local command = startup.command
  ensure_dir(path)
  local handle = fs.open(path, "w")
  if not handle then
    return false, "Unable to write startup stub"
  end
  handle.write("-- Auto-generated by composer for package " .. package_name .. "\n")
  handle.write("local ok, err = pcall(function()\n")
  handle.write("  shell.run(" .. textutils.serialize(command) .. ")\n")
  handle.write("end)\n")
  handle.write("if not ok then\n")
  handle.write("  print('Failed to launch " .. package_name .. ": '..tostring(err))\n")
  handle.write("end\n")
  handle.close()
  return true
end

local function update_state(package_name, manifest)
  state.packages[package_name] = {
    version = manifest.version,
    files = manifest.files,
    startup = manifest.startup,
  }
  save_state()
end

local function perform_install(package_name, manifest)
  if type(manifest.files) ~= "table" or #manifest.files == 0 then
    return false, "Manifest missing files array"
  end

  for _, file in ipairs(manifest.files) do
    if type(file) ~= "table" or not file.path or not file.url then
      return false, "Invalid file descriptor in manifest"
    end
    local ok, err = download_file(file.url, file.path)
    if not ok then
      return false, err or ("Failed to download " .. file.url)
    end
  end

  if manifest.startup then
    local ok, err = write_startup_stub(package_name, manifest.startup)
    if not ok then
      return false, err
    end
  end

  update_state(package_name, manifest)
  return true
end

function composer.install(package_name)
  local index, err = load_index()
  if not index then
    return false, err
  end
  local entry = index[package_name]
  if not entry then
    return false, "Unknown package '" .. package_name .. "'"
  end
  local manifest, m_err = load_manifest(entry)
  if not manifest then
    return false, m_err
  end
  local ok, perr = perform_install(package_name, manifest)
  if not ok then
    return false, perr
  end
  return true, manifest.version
end

function composer.update(package_name)
  return composer.install(package_name)
end

function composer.check(package_name)
  local index, err = load_index()
  if not index then
    return { ok = false, error = err }
  end
  local entry = index[package_name]
  if not entry then
    return { ok = false, error = "Unknown package '" .. package_name .. "'" }
  end
  local manifest, m_err = load_manifest(entry)
  if not manifest then
    return { ok = false, error = m_err }
  end

  local installed_version = nil
  local installed = state.packages[package_name]
  if installed then
    installed_version = installed.version
  end

  local latest_version = manifest.version
  local update_available = false

  if installed_version and latest_version then
    update_available = (installed_version ~= latest_version)
  elseif not installed_version and latest_version then
    -- Not installed at all
    update_available = true
  end

  return {
    ok = true,
    installed_version = installed_version,
    latest_version = latest_version,
    update_available = update_available,
    manifest = manifest,
  }
end

function composer.list()
  local packages = {}
  for name, info in pairs(state.packages) do
    table.insert(packages, { name = name, version = info.version })
  end
  table.sort(packages, function(a, b) return a.name < b.name end)
  return packages
end

function composer.available()
  local index, err = load_index()
  if not index then
    return nil, err
  end

  local packages = {}
  for name, entry in pairs(index) do
    local installed = state.packages[name]
    table.insert(packages, {
      name = name,
      installed = installed ~= nil,
      installed_version = installed and installed.version or nil,
    })
  end
  table.sort(packages, function(a, b) return a.name < b.name end)
  return packages
end

function composer.get_state()
  return state
end

function composer.create_update_checker(package_name, current_version, interval)
  if type(package_name) ~= "string" then
    error("package_name must be a string", 2)
  end
  interval = tonumber(interval) or 30
  if interval < 1 then interval = 1 end

  -- current_version parameter is now optional (kept for backwards compatibility)
  local watcher_state = {
    package = package_name,
    current_version = current_version,
    latest_version = nil,
    update_available = false,
    last_error = nil,
    last_check = nil,
  }

  local function loop()
    while true do
      local result = composer.check(package_name)
      watcher_state.last_check = os.epoch("utc")
      if not result.ok then
        watcher_state.last_error = result.error
      else
        watcher_state.last_error = nil
        watcher_state.current_version = result.installed_version or watcher_state.current_version
        watcher_state.latest_version = result.latest_version
        watcher_state.update_available = result.update_available or false
      end
      sleep(interval)
    end
  end

  return loop, watcher_state
end

return composer
